
"""
Attempts to fetch the content of a URL with retries in case of network issues.
Returns the HTTP response or None if all retries fail.
Scans the given website for vulnerabilities by analyzing its HTML structure and dynamic content.
Detects forms, input fields, and other potentially exploitable elements.
"""

from bs4 import BeautifulSoup
import requests
from playwright.sync_api import sync_playwright
import time

def fetch_with_retry(url, retries=3, delay=5):
    """Attempt to fetch the website with retries in case of connection issues."""
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    for i in range(retries):
        try:
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()  # Raise an HTTPError for bad responses
            return response
        except requests.exceptions.RequestException as e:
            print(f"[!] Attempt {i + 1}/{retries} failed: {e}")
            if i < retries - 1:
                print(f"[!] Retrying in {delay} seconds...")
                time.sleep(delay)
            else:
                print("[!] All retries failed.")
                return None

def scan_website(url):
    """Scan the website for forms, inputs, and other vulnerabilities."""
    vulnerabilities = []

    # Fetch content using requests (for static websites)
    response = fetch_with_retry(url)
    if not response:
        return []

    try:
        # Step 1: Parse the static HTML using BeautifulSoup
        print("[*] Fetched HTML content using requests:")
        print(response.text[:1000])  # Print first 1000 characters of the page content

        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        inputs = soup.find_all('input')
        textareas = soup.find_all('textarea')
        selects = soup.find_all('select')

        print(f"[*] Found {len(forms)} forms, {len(inputs)} inputs, {len(textareas)} textareas, {len(selects)} selects using requests.")

        # Add detected vulnerabilities
        for form in forms:
            vulnerabilities.append({'type': 'Form Detected', 'detail': str(form)})
        for input_element in inputs:
            vulnerabilities.append({'type': 'Input Detected', 'detail': str(input_element)})
        for textarea in textareas:
            vulnerabilities.append({'type': 'Textarea Detected', 'detail': str(textarea)})
        for select in selects:
            vulnerabilities.append({'type': 'Select Detected', 'detail': str(select)})

        if vulnerabilities:
            return vulnerabilities  # Return early if we find static content

        # Step 2: If no forms found, fall back to Playwright for dynamic content
        print("[*] No forms found using requests. Falling back to Playwright...")
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()
            page.goto(url)

            # Step 3: Handle popups or overlays (e.g., cookie consent)
            try:
                page.wait_for_selector('button:has-text("Accept"), button:has-text("OK")', timeout=5000)
                page.click('button:has-text("Accept"), button:has-text("OK")')  # Accept cookie consent if it appears
                print("[*] Cookie consent accepted.")
            except:
                print("[*] No cookie consent button found.")

            # Search for login-related elements (buttons, links, forms, etc.)
            try:
                print("[*] Searching for login button or link...")
                # Wait for login buttons or links (e.g., "Login", "Sign In", "Account", etc.)
                page.wait_for_selector('button:has-text("Login"), button:has-text("Sign In"), a:has-text("Login"), a:has-text("Sign In")', state='visible', timeout=60000)
                print("[*] Login button or link is visible.")
            except:
                print("[*] No login button or link found.")

            # Get the rendered HTML after dynamic JavaScript rendering
            html = page.content()
            print("[*] Fetched HTML content using Playwright (first 1000 characters):")
            print(html[:1000])  # Print first 1000 characters of the rendered HTML

            soup = BeautifulSoup(html, 'html.parser')

            forms = soup.find_all('form')
            inputs = soup.find_all('input')
            textareas = soup.find_all('textarea')
            selects = soup.find_all('select')

            print(f"[*] Found {len(forms)} forms, {len(inputs)} inputs, {len(textareas)} textareas, {len(selects)} selects using Playwright.")

            # Add detected vulnerabilities
            for form in forms:
                vulnerabilities.append({'type': 'Form Detected', 'detail': str(form)})
            for input_element in inputs:
                vulnerabilities.append({'type': 'Input Detected', 'detail': str(input_element)})
            for textarea in textareas:
                vulnerabilities.append({'type': 'Textarea Detected', 'detail': str(textarea)})
            for select in selects:
                vulnerabilities.append({'type': 'Select Detected', 'detail': str(select)})

            browser.close()

    except Exception as e:
        print(f"[!] Error scanning website: {e}")

    return vulnerabilities
