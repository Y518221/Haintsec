
"""
Attempts to fetch the content of a URL with retries in case of network issues.
Returns the HTTP response or None if all retries fail.
Scans the given website for vulnerabilities by analyzing its HTML structure and dynamic content.
Detects forms, input fields, and other potentially exploitable elements.
"""

from bs4 import BeautifulSoup
import requests
from playwright.sync_api import sync_playwright
import time

def fetch_with_retry(url, retries=3, delay=5):
    """Attempt to fetch the website with retries in case of connection issues."""
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    for i in range(retries):
        try:
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()  # Raise an HTTPError for bad responses
            return response
        except requests.exceptions.RequestException as e:
            print(f"[!] Attempt {i + 1}/{retries} failed: {e}")
            if i < retries - 1:
                print(f"[!] Retrying in {delay} seconds...")
                time.sleep(delay)
            else:
                print("[!] All retries failed.")
                return None

def scan_website(url):
    """Scan the website for forms, inputs, and other vulnerabilities."""
    vulnerabilities = []
    html_content = ""

    # Fetch content using requests (for static websites)
    response = fetch_with_retry(url)
    if not response:
        return [], html_content

    try:
        # Step 1: Parse the static HTML using BeautifulSoup
        html_content = response.text  # Store HTML content for the report

        # Debugging: Optional, print the first 1000 characters of HTML content
        # print("[*] Fetched HTML content using requests:")
        # print(html_content[:1000])

        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        inputs = soup.find_all('input')
        textareas = soup.find_all('textarea')
        selects = soup.find_all('select')

        # Add detected vulnerabilities
        for form in forms:
            vulnerabilities.append({'type': 'Form Detected', 'detail': str(form)})
        for input_element in inputs:
            vulnerabilities.append({'type': 'Input Detected', 'detail': str(input_element)})
        for textarea in textareas:
            vulnerabilities.append({'type': 'Textarea Detected', 'detail': str(textarea)})
        for select in selects:
            vulnerabilities.append({'type': 'Select Detected', 'detail': str(select)})

        # If vulnerabilities are found, return early
        if vulnerabilities:
            return vulnerabilities, html_content

        # Step 2: If no forms found, fall back to Playwright for dynamic content
        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()
            page.goto(url)

            # Handle popups or overlays (e.g., cookie consent)
            try:
                page.wait_for_selector('button:has-text("Accept"), button:has-text("OK")', timeout=5000)
                page.click('button:has-text("Accept"), button:has-text("OK")')  # Accept cookie consent if it appears
                print("[*] Cookie consent accepted.")
            except:
                print("[*] No cookie consent button found.")

            # Get the rendered HTML after dynamic JavaScript rendering
            html_content = page.content()  # Store rendered HTML content
            soup = BeautifulSoup(html_content, 'html.parser')

            forms = soup.find_all('form')
            inputs = soup.find_all('input')
            textareas = soup.find_all('textarea')
            selects = soup.find_all('select')

            # Add detected vulnerabilities
            for form in forms:
                vulnerabilities.append({'type': 'Form Detected', 'detail': str(form)})
            for input_element in inputs:
                vulnerabilities.append({'type': 'Input Detected', 'detail': str(input_element)})
            for textarea in textareas:
                vulnerabilities.append({'type': 'Textarea Detected', 'detail': str(textarea)})
            for select in selects:
                vulnerabilities.append({'type': 'Select Detected', 'detail': str(select)})

            browser.close()

    except Exception as e:
        print(f"[!] Error scanning website: {e}")

    return vulnerabilities, html_content
